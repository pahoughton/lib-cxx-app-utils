#ifndef _Bitmask_ii_
#define _Bitmask_ii_
//
// File:        Bitmask.ii
// Project:	StlUtils ()
// Desc:        
//
//  	Inlines sources for Bitmask.
//
// Author:      Paul Houghton - (paul4hough@gmail.com)
// Created:     05/18/95 04:39
//
// Revision History: (See end of file for Revision Log)
//
//  $Author$ 
//  $Date$ 
//  $Name$ 
//  $Revision$ 
//  $State$ 
//
// $Id$ 
//

#include <Compare.hh>
#include <Bit.hh>

#if defined( STLUTILS_DEBUG )
#define inline
#endif


inline
Bitmask::bit &
Bitmask::bit::flip( void )
{
  bitmask.flip( bitpos );
  return( *this );
}

inline
Bitmask::size_type
Bitmask::bit::pos( void ) const
{
  return( bitpos );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( bool rhs )
{
  bitmask.set( bitpos, (rhs) ? 1 : 0 );
  return( *this );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( const bit & rhs )
{
  bitmask.set( bitpos, rhs.bitmask.test( rhs.bitpos ) );
  return( *this );
}

inline
bool
Bitmask::bit::operator ~ ( void ) const
{
  return( ! bitmask.test( bitpos ) );
}

inline
bool
Bitmask::bit::operator ! ( void ) const
{
  return( ! bitmask.test( bitpos ) );
}

inline
Bitmask::bit::operator bool ( void ) const
{
  return( bitmask.test( bitpos ) );
}

inline
Bitmask::bit::bit( Bitmask & owner, size_type position )
  : bitmask( owner ),
    bitpos( position )
{
}

inline
bool
Bitmask::bit::operator == ( bool rhs ) const
{
  return( bitmask.test( bitpos ) ? rhs : ! rhs );
}

inline
bool
Bitmask::bit::operator != ( bool rhs ) const
{
  return( ! ( *this == rhs ) );
}

inline
Bitmask::Bitmask( void )
  : value( 0 )
{
}

inline
Bitmask::Bitmask( value_type val, bool flip )
  : value( val )
{
  if( flip )
    value = ~val;
}

inline
Bitmask::Bitmask( const Bitmask::bit & val )
  : value( 0 )
{
  set( val.pos(), val );
}

inline
Bitmask::Bitmask( const Bitmask & from )
  : value( from.value )
{
}


inline
Bitmask &
Bitmask::set( void )
{
  value = ~0U;
  return( *this );
}

inline
Bitmask &
Bitmask::set( size_type pos, bool val )
{
  if( val )
    value |= 1U << pos;
  else
    value &= ~(1U << pos );
  
  return( *this );
}

inline
Bitmask &
Bitmask::reset( void )
{
  value = 0;
  return( *this );
}

inline
Bitmask &
Bitmask::reset( size_type pos )
{
  return( set( pos, false ) );
}

inline
Bitmask &
Bitmask::flip( void )
{
  value = ~value;
  return( *this );
}

inline
Bitmask &
Bitmask::flip( size_type pos )
{
  return( set( pos, ! test( pos ) ) );
}

inline
bool
Bitmask::test( size_type pos ) const
{
  return( value & (1U << pos) );
}

inline
bool
Bitmask::any( void ) const 
{
  return( value != 0 );
}

inline
bool
Bitmask::none( void ) const
{
  return( value == 0 );
}

inline
Bitmask::size_type
Bitmask::count( void ) const
{
  size_type cnt = 0;
  for( size_type p = 0; p < maxPos; p++ )
    if( test( p ) ) cnt++;

  return( cnt );
}

inline
Bitmask::size_type
Bitmask::size( void ) const
{
  return( maxPos );
}


inline
unsigned long
Bitmask::to_ulong( void ) const
{
  return( value );
}

inline
const char *
Bitmask::to_string( void ) const
{
  static char	tmp[ CHAR_BITS * sizeof( Bitmask::value_type ) ];

  int p = maxPos;
  for( ; p > 0; p-- )
    tmp[ maxPos - p ] = (test(p - 1) ? '1' : '0');
  tmp[ maxPos ] = 0;
  
  return( tmp );
}

inline
Bitmask::value_type
Bitmask::to_value_type( void ) const
{
  return( value );
}

inline
int
Bitmask::compare( const Bitmask & two ) const
{
  return( ::compare( value, two.value ) );
}

inline
int
Bitmask::compare( value_type two ) const
{
  return( ::compare( value, two ) );
}

inline
Bitmask::bit
Bitmask::operator () ( size_type pos )
{
  return( bit( *this, pos ) );
}

inline
Bitmask::bit
Bitmask::operator [] ( size_type pos )
{
  return( bit( *this, pos ) );
}

inline
bool
Bitmask::operator () ( size_type pos ) const
{
  return( test( pos ) );
}

inline
bool
Bitmask::operator [] ( size_type pos ) const
{
  return( test( pos ) );
}

inline
Bitmask &
Bitmask::operator = ( value_type rhs )
{
  value = rhs;
  return( *this );
}

inline
Bitmask &
Bitmask::operator = ( const Bitmask::bit & rhs )
{
  reset();
  set( rhs.pos(), rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) && (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) || (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator ^= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) != (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator =  ( const Bitmask & rhs )
{
  value = rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask & rhs )
{
  value &= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask & rhs )
{
  value |= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator ^= ( const Bitmask & rhs )
{
  value ^= rhs.value;
  return( *this );
}

STLUTILS_SELF_COMPARE_IMPL( Bitmask, == )
STLUTILS_SELF_COMPARE_IMPL( Bitmask, != )
STLUTILS_SELF_COMPARE_IMPL( Bitmask, <  )
STLUTILS_SELF_COMPARE_IMPL( Bitmask, >  )
STLUTILS_SELF_COMPARE_IMPL( Bitmask, <= )
STLUTILS_SELF_COMPARE_IMPL( Bitmask, >= )


inline
bool
Bitmask::operator == ( bool rhs ) const
{
  return( any() == rhs );
}

inline
bool
Bitmask::operator != ( bool rhs ) const
{
  return( !(*this == rhs) );
}
  

inline
bool
Bitmask::operator == ( value_type rhs ) const
{
  return( compare( rhs ) == 0 );
}

inline
bool
Bitmask::operator != ( value_type rhs ) const
{
  return( compare( rhs ) != 0 );
}

inline
bool
Bitmask::operator <  ( value_type rhs ) const
{
  return( compare( rhs ) <  0 );
}

inline
bool
Bitmask::operator <= ( value_type rhs ) const
{
  return( compare( rhs ) <=  0 );
}

inline
bool
Bitmask::operator >  ( value_type rhs ) const
{
  return( compare( rhs ) >  0 );
}

inline
bool
Bitmask::operator >= ( value_type rhs ) const
{
  return( compare( rhs ) >= 0 );
}

inline
Bitmask::operator bool ( void ) const
{
  return( value != 0 );
}

inline
Bitmask::operator value_type ( void ) const
{
  return( value );
}

  
inline
Bitmask
operator & ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret &= rhs;
  return( ret );
}

inline
Bitmask
operator | ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret |= rhs;
  return( ret );
}

inline
Bitmask
operator ^ ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret ^= rhs;
  return( ret );
}

inline
Bitmask
operator ~ ( const Bitmask & mask )
{
  Bitmask::value_type nValue = mask;
  Bitmask ret;

  ret = ~nValue;
  return( ret );
}

inline
bool
operator == ( bool lhs, const Bitmask & rhs )
{
  return( rhs == lhs );
}

inline
bool
operator != ( bool lhs, const Bitmask & rhs )
{
  return( rhs != lhs );
}

inline
int
compare( const Bitmask & one, const Bitmask & two )
{
  return( one.compare( two ) );
}

inline
int
compare( Bitmask::value_type one, const Bitmask & two )
{
  return( compare( one, two.to_value_type() ) );
}

inline
int
compare( const Bitmask & one, Bitmask::value_type two )
{
  return( one.compare( two ) );
}

inline
bool
operator == ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) == 0 );
}

inline
bool
operator != ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) != 0 );
}

inline
bool
operator <  ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) <  0 );
}

inline
bool
operator <= ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) <= 0 );
}

inline
bool
operator >  ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) >  0 );
}

inline
bool
operator >= ( Bitmask::value_type lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) >=  0 );
}


inline
std::ostream &
operator << ( std::ostream & dest, const Bitmask & obj )
{
  return( obj.toStream( dest ) );
}

inline
std::istream &
operator >> ( std::istream & src, Bitmask & obj )
{
  return( obj.fromStream( src ) );
}

inline
std::ostream &
operator << ( std::ostream & dest, const Bitmask::bit & obj )
{
  return( obj.toStream( dest ) );
}

#if defined( inline )
#undef inline
#endif

//
// Revision Log:
//
// 
// %PL%
// 
// $Log$
// Revision 6.3  2012/04/26 20:08:55  paul
// *** empty log message ***
//
// Revision 6.2  2011/12/30 23:57:10  paul
// First go at Mac gcc Port
//
// Revision 6.1  2003/08/09 11:22:40  houghton
// Changed to version 6
//
// Revision 5.4  2003/08/09 11:20:58  houghton
// Changed ver strings.
//
// Revision 5.3  2003/07/19 09:17:12  houghton
// Port to 64 bit.
//
// Revision 5.2  2001/07/26 19:29:01  houghton
// *** empty log message ***
//
// Revision 5.1  2000/05/25 10:33:14  houghton
// Changed Version Num to 5
//
// Revision 4.3  1998/10/13 16:14:08  houghton
// Changed ValueType to value_type for consistency.
//
// Revision 4.2  1998/07/20 11:19:42  houghton
// Port(Hpux): Added operatoer == (bool) && operator != (bool).
//
// Revision 4.1  1997/09/17 15:12:11  houghton
// Changed to Version 4
//
// Revision 3.3  1997/09/17 11:08:10  houghton
// Changed: renamed library to StlUtils.
//
// Revision 3.2  1996/11/19 12:20:10  houghton
// Restructure header comments.
//
// Revision 3.1  1996/11/14 01:23:27  houghton
// Changed to Release 3
//
// Revision 2.7  1996/11/11 13:30:24  houghton
// Added Bitmask::bit::operator ! ( void )
// Added Bitmask::bit::operator == ( bool )
// Added Bitmask::bit::operator != ( bool )
// Added ::operator == ( bool lhs, const Bitmask::bit & rhs );
// Added ::operator != ( bool lhs, const Bitmask::bit & rhs );
//
// Revision 2.6  1996/11/04 13:27:10  houghton
// Restructure header comments layout.
// Added Copy Constructor.
// Changed to_string to return a const char *.
// Reorder functions to match header order.
// Added ::operator >> ( std::istream, Bitmask )
// Added ::operator << ( std::ostream, Bitmask::bit )
//
// Revision 2.5  1996/05/02 01:27:28  houghton
// Add missing operators for <= & >= long rhs.
//
// Revision 2.4  1996/04/27 12:51:56  houghton
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.3  1995/12/31 11:21:29  houghton
// Bug fix - Needed cast for AIX.
//
// Revision 2.2  1995/12/04 11:16:45  houghton
// Bug Fix - Can now compile with out '-DSTLUTILS_DEBUG'.
// Bug Fix - Now there is a special type for all single 'bit' values.
//
// Revision 2.1  1995/11/10  12:40:18  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:32  houghton
// Revised
//
//
#endif // ! def _Bitmask_ii_ 
