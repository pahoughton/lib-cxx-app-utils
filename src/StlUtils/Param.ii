#ifndef _Param_ii_
#define _Param_ii_
//
// File:        Param.ii
// Project:	Clue
// Desc:        
//
//  	Inline source for Param
//
// Author:      Paul Houghton - (paul.houghton@wcom.com)
// Created:     06/16/95 04:11
//
// Revision History: (See end of file for Revision Log)
//
//  Last Mod By:    $Author$
//  Last Mod:	    $Date$
//  Version:	    $Revision$
//
//  $Id$
//


#include <StringUtils.hh>

#if defined( CLUE_DEBUG )
#define inline
#endif


inline
Log &
Param::log( void )
{
  return( appLog );
}

inline
Log &
Param::log( LogLevel::Level lvl )
{
  return( appLog.level( lvl ) );
}

inline
size_t
Param::count( void ) const
{
  return( argv.size() );
}

inline
Param::Args::const_iterator
Param::begin( void ) const
{
  return( argv.begin() );
}

inline
Param::Args::const_iterator
Param::end( void ) const
{
  return( argv.end() );
}

inline
Param::Args::const_iterator
Param::beginAll( void ) const
{
  return( allArgv.begin() );
}

inline
Param::Args::const_iterator
Param::endAll( void ) const
{
  return( allArgv.end() );
}

inline
bool
Param::setArgFileName( const char * name )
{
  if( name )
    argFile = name;
  return( argFile.size() > 0 );
}

inline
const char *
Param::arg( size_t which )
{
  return( (which < count()) ? argv[which].c_str() : 0 );
}

inline
long
Param::argLong( size_t which )
{
  if( which < count() )
    {
      return( StringToLong( argv[which].c_str() ) );
    }
  else
    {
      return( -1 );
    }  
}

inline
double
Param::argDouble( size_t which )
{
  if( which < count() )
    {
      return( StringToDouble( argv[which].c_str() ) );
    }
  else
    {
      return( -1.0 );
    }  
}

inline
bool
Param::readArgs( const char * fileName )
{
  ifstream  in( fileName );

  if( in.good() )
    return( readArgs( in ) );
  else
    return( false );
}

inline
const char *
Param::env( const char * envVar ) const
{
  return( envVar ? getenv( envVar ) : 0 );
}

inline
bool
Param::help( void ) const
{
  return( helpFlag );
}

inline
bool
Param::allArgs( void ) const
{
  return( count() == 1 );
}

inline
DumpInfo< Param >
Param::dump( const char * prefix, bool showVer ) const
{
  return( DumpInfo< Param >( *this, prefix, showVer ) );
}

inline
ostream &
operator<<( ostream & dest, const Param & obj )
{
  return( obj.toStream( dest ) );
}


#if defined( inline )
#undef inline
#endif

// Revision Log:
// 
//
// $Log$
// Revision 3.7  1997/07/18 19:25:48  houghton
// Port(Sun5): changed local variable names to eliminate compiler warnings.
//
// Revision 3.6  1997/04/04 20:54:54  houghton
// Cleanup.
//
// Revision 3.5  1997/03/26 12:32:18  houghton
// Added setArgFileName.
//
// Revision 3.4  1997/03/21 12:28:22  houghton
// Cleanup.
// Added dump().
//
// Revision 3.3  1996/11/19 22:09:37  houghton
// Bug-Fix: had to move operator << to before Param::abort because
//     it is used by Param::abort.
// Bug-Fix: cleanup abort output.
//
// Revision 3.2  1996/11/19 12:25:48  houghton
// Major re-work to use 'string'
// Major re-work to use vector<string> for managing argv.
//
// Revision 3.1  1996/11/14 01:23:54  houghton
// Changed to Release 3
//
// Revision 2.3  1996/02/29 19:06:48  houghton
// *** empty log message ***
//
// Revision 2.2  1995/12/04 11:18:23  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
//
// Revision 2.1  1995/11/10  12:40:55  houghton
// Change to Version 2
//
// Revision 1.2  1995/11/05  15:28:45  houghton
// Revised
//
//
#endif // ! def _Param_ii_ 
