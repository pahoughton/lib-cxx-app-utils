#ifndef _Param_ii_
#define _Param_ii_
//
// File:        Param.ii
// Project:	Clue
// Desc:        
//
//  	Inline source for Param
//
// Author:      Paul Houghton - (paul.houghton@wcom.com)
// Created:     06/16/95 04:11
//
// Revision History: (See end of file for Revision Log)
//
//  Last Mod By:    $Author$
//  Last Mod:	    $Date$
//  Version:	    $Revision$
//
//  $Id$
//


#include <StringUtils.hh>

#if defined( CLUE_DEBUG )
#define inline
#endif


inline
Log &
Param::log( void )
{
  return( appLog );
}

inline
Log &
Param::log( LogLevel::Level lvl )
{
  return( appLog.level( lvl ) );
}

inline
const char *
Param::appName( void ) const
{
  return( basename( argv[0].c_str() ) );
}

inline
const char *
Param::appFullName( void ) const
{
  return( argv[0].c_str() );
}

inline
const char *
Param::appVersion( void ) const
{
  return( ver.c_str() );
}

inline
size_t
Param::count( void ) const
{
  return( argv.size() );
}

inline
Param::Args::const_iterator
Param::begin( void ) const
{
  return( argv.begin() );
}

inline
Param::Args::const_iterator
Param::end( void ) const
{
  return( argv.end() );
}

inline
Param::Args::const_iterator
Param::beginAll( void ) const
{
  return( allArgv.begin() );
}

inline
Param::Args::const_iterator
Param::endAll( void ) const
{
  return( allArgv.end() );
}

inline
const char *
Param::arg( size_t which )
{
  return( (which < count()) ? argv[which].c_str() : 0 );
}

inline
long
Param::argLong( size_t which )
{
  if( which < count() )
    {
      return( StringToLong( argv[which].c_str() ) );
    }
  else
    {
      return( -1 );
    }  
}

inline
double
Param::argDouble( size_t which )
{
  if( which < count() )
    {
      return( StringToDouble( argv[which].c_str() ) );
    }
  else
    {
      return( -1.0 );
    }  
}

inline
bool
Param::readArgs( const char * fileName )
{
  ifstream  argFile( fileName );

  if( argFile.good() )
    return( readArgs( argFile ) );
  else
    return( false );
}

inline
const char *
Param::env( const char * envVar ) const
{
  return( envVar ? getenv( envVar ) : 0 );
}

inline
bool
Param::help( void ) const
{
  return( helpFlag );
}

inline
bool
Param::allArgs( void ) const
{
  return( count() == 1 );
}

inline
DumpInfo< Param >
Param::dump( const char * prefix, bool showVer ) const
{
  return( DumpInfo< Param >( *this, prefix, showVer ) );
}

inline
ostream &
operator<<( ostream & dest, const Param & obj )
{
  return( obj.toStream( dest ) );
}

inline
void
Param::abort(
  int		exitStatus,
  bool		showArgs,
  const char *	srcFile,
  long		srcLine,
  ostream &	mesgDest )
{
  if( showArgs )
    mesgDest << *this << endl;

  if( exitStatus )
    mesgDest << "Aborted(" << exitStatus << ")";
  else
    mesgDest << "Exited";
  
  if( srcFile )
    mesgDest << ": " << srcFile << ':' << srcLine << ' ';

  if( log().rdbuf()->is_file() )
    mesgDest << ": see log (" << log().rdbuf()->getLogFileName()
	     << ") for more info." << endl;
  else
    mesgDest << '.' << endl;
  
  exit( exitStatus );
}



#if defined( inline )
#undef inline
#endif

// Revision Log:
// 
//
// $Log$
// Revision 3.4  1997/03/21 12:28:22  houghton
// Cleanup.
// Added dump().
//
// Revision 3.3  1996/11/19 22:09:37  houghton
// Bug-Fix: had to move operator << to before Param::abort because
//     it is used by Param::abort.
// Bug-Fix: cleanup abort output.
//
// Revision 3.2  1996/11/19 12:25:48  houghton
// Major re-work to use 'string'
// Major re-work to use vector<string> for managing argv.
//
// Revision 3.1  1996/11/14 01:23:54  houghton
// Changed to Release 3
//
// Revision 2.3  1996/02/29 19:06:48  houghton
// *** empty log message ***
//
// Revision 2.2  1995/12/04 11:18:23  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
//
// Revision 2.1  1995/11/10  12:40:55  houghton
// Change to Version 2
//
// Revision 1.2  1995/11/05  15:28:45  houghton
// Revised
//
//
#endif // ! def _Param_ii_ 
