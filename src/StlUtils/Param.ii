#ifndef _Param_ii_
#define _Param_ii_
//
// File:        Param.ii
// Desc:        
//
//  	inlines for Param
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     06/16/95 04:11
//
// Revision History:
//
// $Log$
// Revision 3.2  1996/11/19 12:25:48  houghton
// Major re-work to use 'string'
// Major re-work to use vector<string> for managing argv.
//
// Revision 3.1  1996/11/14 01:23:54  houghton
// Changed to Release 3
//
// Revision 2.3  1996/02/29 19:06:48  houghton
// *** empty log message ***
//
// Revision 2.2  1995/12/04 11:18:23  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
//
// Revision 2.1  1995/11/10  12:40:55  houghton
// Change to Version 2
//
// Revision 1.2  1995/11/05  15:28:45  houghton
// Revised
//
//

#if !defined( CLUE_SHORT_FN )
#include <StringUtils.hh>
#else
#include <StrUtil.hh>
#endif

#if defined( CLUE_DEBUG )
#define inline
#endif


inline
Log &
Param::log( void )
{
  return( appLog );
}

inline
Log &
Param::log( LogLevel::Level lvl )
{
  return( appLog.level( lvl ) );
}

inline
const char *
Param::appName( void ) const
{
  return( basename( argv[0].c_str() ) );
}

inline
const char *
Param::appFullName( void ) const
{
  return( argv[0].c_str() );
}

inline
const char *
Param::appVersion( void ) const
{
  return( ver.c_str() );
}

inline
size_t
Param::count( void ) const
{
  return( argv.size() );
}

inline
Param::Args::const_iterator
Param::begin( void ) const
{
  return( argv.begin() );
}

inline
Param::Args::const_iterator
Param::end( void ) const
{
  return( argv.end() );
}

inline
Param::Args::const_iterator
Param::beginAll( void ) const
{
  return( allArgv.begin() );
}

inline
Param::Args::const_iterator
Param::endAll( void ) const
{
  return( allArgv.end() );
}

inline
const char *
Param::arg( size_t which )
{
  return( (which < count()) ? argv[which].c_str() : 0 );
}

inline
long
Param::argLong( size_t which )
{
  if( which < count() )
    {
      return( StringToLong( argv[which].c_str() ) );
    }
  else
    {
      return( -1 );
    }  
}

inline
double
Param::argDouble( size_t which )
{
  if( which < count() )
    {
      return( StringToDouble( argv[which].c_str() ) );
    }
  else
    {
      return( -1.0 );
    }  
}

inline
const char *
Param::env( const char * envVar ) const
{
  return( envVar ? getenv( envVar ) : 0 );
}

inline
bool
Param::help( void ) const
{
  return( helpFlag );
}

inline
bool
Param::allArgs( void ) const
{
  return( count() == 1 );
}

inline
void
Param::abort(
  int		exitStatus,
  bool		showArgs,
  const char *	srcFile,
  long		srcLine,
  ostream &	mesgDest )
{
  if( showArgs )
    mesgDest << *this << endl;

  if( exitStatus )
    mesgDest << "Aborted(" << exitStatus << ") : ";
  else
    mesgDest << "Exited: ";
  
  if( srcFile )
    mesgDest << srcFile << ':' << srcLine << ' ';

  if( log().rdbuf()->is_file() )
    mesgDest << "see log (" << log().rdbuf()->getLogFileName()
	     << ") for more info" << endl;

  exit( exitStatus );
}


inline
ostream &
operator<<( ostream & dest, const Param & obj )
{
  return( obj.toStream( dest ) );
}

#if defined( inline )
#undef inline
#endif

#endif // ! def _Param_ii_ 
