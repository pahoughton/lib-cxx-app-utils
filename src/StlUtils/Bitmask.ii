#ifndef _Bitmask_ii_
#define _Bitmask_ii_
//
// File:        Bitmask.ii
// Desc:        
//
//  	inlines for Bitmask
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     05/18/95 04:39
//
// Revision History:
//
// $Log$
// Revision 2.7  1996/11/11 13:30:24  houghton
// Added Bitmask::bit::operator ! ( void )
// Added Bitmask::bit::operator == ( bool )
// Added Bitmask::bit::operator != ( bool )
// Added ::operator == ( bool lhs, const Bitmask::bit & rhs );
// Added ::operator != ( bool lhs, const Bitmask::bit & rhs );
//
// Revision 2.6  1996/11/04 13:27:10  houghton
// Restructure header comments layout.
// Added Copy Constructor.
// Changed to_string to return a const char *.
// Reorder functions to match header order.
// Added ::operator >> ( istream, Bitmask )
// Added ::operator << ( ostream, Bitmask::bit )
//
// Revision 2.5  1996/05/02 01:27:28  houghton
// Add missing operators for <= & >= long rhs.
//
// Revision 2.4  1996/04/27 12:51:56  houghton
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.3  1995/12/31 11:21:29  houghton
// Bug fix - Needed cast for AIX.
//
// Revision 2.2  1995/12/04 11:16:45  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
// Bug Fix - Now there is a special type for all single 'bit' values.
//
// Revision 2.1  1995/11/10  12:40:18  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:32  houghton
// Revised
//
//

#include <Compare.hh>
#include <Bit.hh>

#if defined( CLUE_DEBUG )
#define inline
#endif


inline
Bitmask::bit &
Bitmask::bit::flip( void )
{
  bitmask.flip( bitpos );
  return( *this );
}

inline
size_t
Bitmask::bit::pos( void ) const
{
  return( bitpos );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( bool rhs )
{
  bitmask.set( bitpos, (rhs) ? 1 : 0 );
  return( *this );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( const bit & rhs )
{
  bitmask.set( bitpos, rhs.bitmask.test( rhs.bitpos ) );
  return( *this );
}

inline
bool
Bitmask::bit::operator ~ ( void ) const
{
  return( ! bitmask.test( bitpos ) );
}

inline
bool
Bitmask::bit::operator ! ( void ) const
{
  return( ! bitmask.test( bitpos ) );
}

inline
Bitmask::bit::operator bool ( void ) const
{
  return( bitmask.test( bitpos ) );
}

inline
Bitmask::bit::bit( Bitmask & owner, size_t position )
  : bitmask( owner ),
    bitpos( position )
{
}

inline
bool
Bitmask::bit::operator == ( bool rhs ) const
{
  return( bitmask.test( bitpos ) ? rhs : ! rhs );
}

inline
bool
Bitmask::bit::operator != ( bool rhs ) const
{
  return( ! ( *this == rhs ) );
}

inline
Bitmask::Bitmask( void )
  : value( 0 )
{
}

inline
Bitmask::Bitmask( unsigned long val, bool flip )
  : value( val )
{
  if( flip )
    value = ~val;
}

inline
Bitmask::Bitmask( const Bitmask::bit & val )
  : value( 0 )
{
  set( val.pos(), val );
}

inline
Bitmask::Bitmask( const Bitmask & from )
  : value( from.value )
{
}


inline
Bitmask &
Bitmask::set( void )
{
  value = ~0UL;
  return( *this );
}

inline
Bitmask &
Bitmask::set( size_t pos, bool val )
{
  if( val )
    value |= 1UL << pos;
  else
    value &= ~(1UL << pos );
  
  return( *this );
}

inline
Bitmask &
Bitmask::reset( void )
{
  value = 0;
  return( *this );
}

inline
Bitmask &
Bitmask::reset( size_t pos )
{
  return( set( pos, false ) );
}

inline
Bitmask &
Bitmask::flip( void )
{
  value = ~value;
  return( *this );
}

inline
Bitmask &
Bitmask::flip( size_t pos )
{
  return( set( pos, ! test( pos ) ) );
}

inline
bool
Bitmask::test( size_t pos ) const
{
  return( value & (1UL << pos) );
}

inline
bool
Bitmask::any( void ) const 
{
  return( value != 0 );
}

inline
bool
Bitmask::none( void ) const
{
  return( value == 0 );
}

inline
size_t
Bitmask::count( void ) const
{
  size_t cnt = 0;
  for( size_t p = 0; p < maxPos; p++ )
    if( test( p ) ) cnt++;

  return( cnt );
}

inline
size_t
Bitmask::size( void ) const
{
  return( maxPos );
}


inline
unsigned long
Bitmask::to_ulong( void ) const
{
  return( value );
}

inline
const char *
Bitmask::to_string( void ) const
{
  static char	tmp[ CHAR_BITS * sizeof( Bitmask::ValueType ) ];

  int p = maxPos;
  for( ; p > 0; p-- )
    tmp[ maxPos - p ] = (test(p - 1) ? '1' : '0');
  tmp[ maxPos ] = 0;
  
  return( tmp );
}


inline
int
Bitmask::compare( const Bitmask & two ) const
{
  return( ::compare( value, two.value ) );
}

inline
int
Bitmask::compare( unsigned long two ) const
{
  return( ::compare( value, two ) );
}

inline
Bitmask::bit
Bitmask::operator () ( size_t pos )
{
  return( bit( *this, pos ) );
}

inline
Bitmask::bit
Bitmask::operator [] ( size_t pos )
{
  return( bit( *this, pos ) );
}

inline
bool
Bitmask::operator () ( size_t pos ) const
{
  return( test( pos ) );
}

inline
bool
Bitmask::operator [] ( size_t pos ) const
{
  return( test( pos ) );
}

inline
Bitmask &
Bitmask::operator = ( unsigned long rhs )
{
  value = rhs;
  return( *this );
}

inline
Bitmask &
Bitmask::operator = ( const Bitmask::bit & rhs )
{
  reset();
  set( rhs.pos(), rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) && (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) || (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator ^= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) != (bool)rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator =  ( const Bitmask & rhs )
{
  value = rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask & rhs )
{
  value &= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask & rhs )
{
  value |= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator ^= ( const Bitmask & rhs )
{
  value ^= rhs.value;
  return( *this );
}

inline
bool
Bitmask::operator == ( const Bitmask & rhs ) const
{
  return( compare( rhs ) == 0 );
}

inline
bool
Bitmask::operator <  ( const Bitmask & rhs ) const
{
  return( compare( rhs ) < 0 );
}

inline
bool
Bitmask::operator == ( unsigned long rhs ) const
{
  return( compare( rhs ) == 0 );
}

inline
bool
Bitmask::operator != ( unsigned long rhs ) const
{
  return( compare( rhs ) != 0 );
}

inline
bool
Bitmask::operator <  ( unsigned long rhs ) const
{
  return( compare( rhs ) <  0 );
}

inline
bool
Bitmask::operator <= ( unsigned long rhs ) const
{
  return( compare( rhs ) <=  0 );
}

inline
bool
Bitmask::operator >  ( unsigned long rhs ) const
{
  return( compare( rhs ) >  0 );
}

inline
bool
Bitmask::operator >= ( unsigned long rhs ) const
{
  return( compare( rhs ) >= 0 );
}

inline
Bitmask::operator bool ( void ) const
{
  return( value != 0 );
}

inline
Bitmask::operator unsigned long ( void ) const
{
  return( to_ulong() );
}

  
inline
Bitmask
operator & ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret &= rhs;
  return( ret );
}

inline
Bitmask
operator | ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret |= rhs;
  return( ret );
}

inline
Bitmask
operator ^ ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret ^= rhs;
  return( ret );
}

inline
Bitmask
operator ~ ( const Bitmask & mask )
{
  unsigned long nValue = mask;
  Bitmask ret;

  ret = ~nValue;
  return( ret );
}

inline
bool
operator == ( bool lhs, const Bitmask & rhs )
{
  return( rhs == lhs );
}

inline
bool
operator != ( bool lhs, const Bitmask & rhs )
{
  return( rhs != lhs );
}

inline
int
compare( const Bitmask & one, const Bitmask & two )
{
  return( one.compare( two ) );
}

inline
int
compare( unsigned long one, const Bitmask & two )
{
  return( compare( one, two.to_ulong() ) );
}

inline
int
compare( const Bitmask & one, unsigned long two )
{
  return( one.compare( two ) );
}

inline
bool
operator == ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) == 0 );
}

inline
bool
operator != ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) != 0 );
}

inline
bool
operator <  ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) <  0 );
}

inline
bool
operator <= ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) <= 0 );
}

inline
bool
operator >  ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) >  0 );
}

inline
bool
operator >= ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) >=  0 );
}


inline
ostream &
operator << ( ostream & dest, const Bitmask & obj )
{
  return( obj.toStream( dest ) );
}

inline
istream &
operator >> ( istream & src, Bitmask & obj )
{
  return( obj.fromStream( src ) );
}

inline
ostream &
operator << ( ostream & dest, const Bitmask::bit & obj )
{
  return( obj.toStream( dest ) );
}

#if defined( inline )
#undef inline
#endif

#endif // ! def _Bitmask_ii_ 
