#ifndef _Bitmask_ii_
#define _Bitmask_ii_
//
// File:        Bitmask.ii
// Desc:        
//
//  	inlines for Bitmask
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     05/18/95 04:39
//
// Revision History:
//
// $Log$
// Revision 2.2  1995/12/04 11:16:45  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
// Bug Fix - Now there is a special type for all single 'bit' values.
//
// Revision 2.1  1995/11/10  12:40:18  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:32  houghton
// Revised
//
//

#include <Compare.hh>

#if defined( CLUE_DEBUG )
#define inline
#endif


inline
Bitmask::bit &
Bitmask::bit::flip( void )
{
  bitmask.flip( bitpos );
  return( *this );
}

inline
size_t
Bitmask::bit::pos( void ) const
{
  return( bitpos );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( bool rhs )
{
  bitmask.set( bitpos, (rhs) ? 1 : 0 );
  return( *this );
}

inline
Bitmask::bit &
Bitmask::bit::operator = ( const bit & rhs )
{
  bitmask.set( bitpos, rhs.bitmask.test( rhs.bitpos ) );
  return( *this );
}

inline
bool
Bitmask::bit::operator ~ ( void ) const
{
  return( ! bitmask.test( bitpos ) );
}

inline
Bitmask::bit::operator bool ( void ) const
{
  return( bitmask.test( bitpos ) );
}

inline
Bitmask::bit::bit( Bitmask & owner, size_t position )
  : bitmask( owner ),
    bitpos( position )
{
}


inline
Bitmask::Bitmask( void )
  : value( 0 )
{
}

inline
Bitmask::Bitmask( const Bitmask::bit & val )
  : value( 0 )
{
  set( val.pos(), val );
}

inline
Bitmask::Bitmask( unsigned long val, bool flip )
  : value( val )
{
  if( flip )
    value = ~val;
}

inline
Bitmask &
Bitmask::set( void )
{
  value = ~0UL;
  return( *this );
}

inline
Bitmask &
Bitmask::set( size_t pos, bool val )
{
  if( val )
    value |= 1UL << pos;
  else
    value &= ~(1UL << pos );
  
  return( *this );
}

inline
Bitmask &
Bitmask::reset( void )
{
  value = 0;
  return( *this );
}

inline
Bitmask &
Bitmask::reset( size_t pos )
{
  return( set( pos, false ) );
}

inline
Bitmask &
Bitmask::flip( void )
{
  value = ~value;
  return( *this );
}

inline
Bitmask &
Bitmask::flip( size_t pos )
{
  return( set( pos, ! test( pos ) ) );
}

inline
bool
Bitmask::test( size_t pos ) const
{
  return( value & (1UL << pos) );
}

inline
bool
Bitmask::any( void ) const 
{
  return( value != 0 );
}

inline
bool
Bitmask::none( void ) const
{
  return( value == 0 );
}

inline
size_t
Bitmask::count( void ) const
{
  size_t cnt = 0;
  for( size_t p = 0; p < maxPos; p++ )
    if( test( p ) ) cnt++;

  return( cnt );
}

inline
size_t
Bitmask::size( void ) const
{
  return( maxPos );
}


inline
unsigned long
Bitmask::to_ulong( void ) const
{
  return( value );
}

inline
Str
Bitmask::to_string( void ) const
{
  Str tmp;
  toStream( tmp );
  return( tmp );
}


inline
int
Bitmask::compare( const Bitmask & two ) const
{
  return( ::compare( value, two.value ) );
}

inline
int
Bitmask::compare( unsigned long two ) const
{
  return( ::compare( value, two ) );
}

inline
Bitmask &
Bitmask::operator = ( unsigned long rhs )
{
  value = rhs;
  return( *this );
}

inline
Bitmask &
Bitmask::operator = ( const Bitmask::bit & rhs )
{
  reset();
  set( rhs.pos(), rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) && rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask::bit & rhs )
{
  set( rhs.pos(), test( rhs.pos() ) || rhs );
  return( *this );
}

inline
Bitmask &
Bitmask::operator &= ( const Bitmask & rhs )
{
  value &= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator |= ( const Bitmask & rhs )
{
  value |= rhs.value;
  return( *this );
}

inline
Bitmask &
Bitmask::operator ^= ( const Bitmask & rhs )
{
  value ^= rhs.value;
  return( *this );
}

inline
Bitmask::bit
Bitmask::operator () ( size_t pos )
{
  return( bit( *this, pos ) );
}

inline
Bitmask::bit
Bitmask::operator [] ( size_t pos )
{
  return( bit( *this, pos ) );
}

inline
bool
Bitmask::operator () ( size_t pos ) const
{
  return( test( pos ) );
}

inline
bool
Bitmask::operator [] ( size_t pos ) const
{
  return( test( pos ) );
}

inline
bool
Bitmask::operator == ( const Bitmask & rhs ) const
{
  return( compare( rhs ) == 0 );
}

inline
bool
Bitmask::operator <  ( const Bitmask & rhs ) const
{
  return( compare( rhs ) < 0 );
}

inline
bool
Bitmask::operator == ( unsigned long rhs ) const
{
  return( compare( rhs ) == 0 );
}

inline
bool
Bitmask::operator != ( unsigned long rhs ) const
{
  return( compare( rhs ) != 0 );
}

inline
bool
Bitmask::operator <  ( unsigned long rhs ) const
{
  return( compare( rhs ) <  0 );
}

inline
bool
Bitmask::operator >  ( unsigned long rhs ) const
{
  return( compare( rhs ) >  0 );
}

inline
Bitmask::operator bool ( void ) const
{
  return( value != 0 );
}

inline
Bitmask::operator unsigned long ( void ) const
{
  return( to_ulong() );
}

  
inline
Bitmask
operator & ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret &= rhs;
  return( ret );
}

inline
Bitmask
operator | ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret |= rhs;
  return( ret );
}

inline
Bitmask
operator ^ ( const Bitmask & lhs, const Bitmask & rhs )
{
  Bitmask ret( lhs );
  ret ^= rhs;
  return( ret );
}

inline
Bitmask
operator ~ ( const Bitmask & mask )
{
  unsigned long nValue = mask;
  Bitmask ret;

  ret = ~nValue;
  return( ret );
}

inline
int
compare( const Bitmask & one, const Bitmask & two )
{
  return( one.compare( two ) );
}

inline
int
compare( unsigned long one, const Bitmask & two )
{
  return( compare( one, two.to_ulong() ) );
}

inline
int
compare( const Bitmask & one, unsigned long two )
{
  return( one.compare( two ) );
}

inline
bool
operator == ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) == 0 );
}

inline
bool
operator != ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) != 0 );
}

inline
bool
operator <  ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) <  0 );
}

inline
bool
operator >  ( unsigned long lhs, const Bitmask & rhs )
{
  return( ::compare( lhs, rhs ) >  0 );
}


inline
ostream &
operator << ( ostream & dest, const Bitmask & obj )
{
  return( obj.toStream( dest ) );
}

#endif // ! def _Bitmask_ii_ 
