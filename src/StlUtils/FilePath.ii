#ifndef _FilePath_ii_
#define _FilePath_ii_
//
// File:        FilePath.ii
// Project:	StlUtils
// Desc:        
//
//  	Inline source for FilePath
//
// Author:      Paul Houghton - (paul.houghton@wcom.com)
// Created:     06/15/95 07:47
//
// Revision History: (See end of file for Revision Log)
//
//  Last Mod By:    $Author$
//  Last Mod:	    $Date$
//  Version:	    $Revision$
//
//  $Id$
//



#if defined( STLUTILS_DEBUG )
#define inline
#endif

inline
FilePath::FilePath( char d, char e )
{
  dirDelim = d;
  extDelim = e;
}

inline
FilePath::FilePath( const char * fullName, char d, char e  )
{
  assign( fullName );
  dirDelim = d;
  extDelim = e;
}

inline
FilePath::FilePath(
  const char * 	dir,
  const char * 	fn,
  char 	    	d,
  char 	    	e
  )
{
  assign( dir );
  dirDelim = d;
  extDelim = e;

  if( at( size() - 1 ) != dirDelim )
    append( 1, dirDelim );

  append( fn );
}

inline
FilePath::FilePath(
  const char * 	dir,
  const char * 	fn,
  const char *  ext,
  char 	    	d,
  char 	    	e
  )
  : dirDelim( d ),
    extDelim( e )
{
  if( dir )
    {
      assign( dir );
      
      if( at( size() - 1 ) != dirDelim )
	append( 1, dirDelim );
    }

  if( fn )
    append( fn );

  if( ext )
    {
      if( ext[0] != extDelim )
	append( 1, extDelim );
      append( ext );
    }
}

inline
FilePath::FilePath( const FilePath & from )
{
  assign( from );
  dirDelim = from.dirDelim;
  extDelim = from.extDelim;
}

inline
Str
FilePath::getFullName( void ) const
{
  return( c_str() );
}

inline
Str
FilePath::getPath( void ) const
{
  Str path;

  size_t end = rfind( dirDelim );

  if( end != npos )
    path = substr( (size_type)0, end );

  return( path );
}

inline
Str
FilePath::getFileName( void ) const
{
  Str name;
  
  size_t dirBeg = rfind( dirDelim );

  if( dirBeg != npos )
    name = substr( dirBeg + 1 );

  return( name );
}


inline
Str
FilePath::getExt( void ) const
{
  Str ext;
  
  size_t extBeg = rfind( extDelim );

  if( extBeg != npos )
    ext = substr( extBeg + 1 );

  return( ext );
}

inline
size_t
FilePath::getDepth( void ) const
{
  size_t depth = 0;
  for( size_t start = 0;
       start != npos;
       start = find( DirDelim, start + 1 ) )
    depth++;

  return( depth );
}

inline
char
FilePath::dirSep( void ) const
{
  return( dirDelim );
}

inline
bool
FilePath::set( const char * fullPath )
{
  assign( fullPath );
  return( true );
}

inline
bool
FilePath::set( const Str & fullPath )
{
  return( set( fullPath.c_str() ) );
}

inline
bool
FilePath::setPrefix( const Str & prefix )
{
  return( setPrefix( prefix.c_str() ) );
}

inline
bool
FilePath::setPath( const Str & path )
{
  return( setPath( path.c_str() ) );
}

inline
bool
FilePath::setFileName( const Str & name )
{
  return( setFileName( name.c_str() ) );
}

inline
bool
FilePath::setName( const Str & name )
{
  return( setName( name.c_str() ) );
}

inline
bool
FilePath::setName( const Str & name, char ext )
{
  return( setName( name.c_str(), ext ) );
}

inline
bool
FilePath::setName( const Str & name, const Str & ext )
{
  return( setName( name.c_str(), ext.c_str() ) );
}

inline
bool
FilePath::setExt( const Str & ext )
{
  return( setExt( ext.c_str() ) );
}

inline
bool
FilePath::setExt( const Str & ext, char delim )
{
  return( setExt( ext.c_str(), delim ) );
}

inline
bool
FilePath::setExt( const Str & oldExt, const Str & newExt )
{
  return( setExt( oldExt.c_str(), newExt.c_str() ) );
}

inline
bool
FilePath::setTempName( const Str & prefix )
{
  return( setTempName( prefix.c_str() ) );
}

inline
bool
FilePath::setTempName( const Str & path, const Str & prefix )
{
  return( setTempName( path.c_str(), prefix.c_str() ) );
}

inline
bool
FilePath::changePath( const Str & oldDirs, const Str & newDirs )
{
  return( changePath( oldDirs.c_str(), newDirs.c_str() ) );
}

inline
bool
FilePath::operator == ( const FilePath & rhs ) const
{
  return( compare( rhs ) == 0);
}

inline
bool
FilePath::operator <  ( const FilePath & rhs ) const
{
  return( compare( rhs ) < 0 );
}

inline
int
compare( const FilePath & one, const FilePath & two )
{
  return( one.compare( two ) );
}

inline
ostream &
operator << ( ostream & dest, const FilePath & obj )
{
  return( obj.toStream( dest ) );
}

#if defined( inline )
#undef inline
#endif

// Revision Log:
// 
// $Log$
// Revision 4.2  1998/10/13 15:17:59  houghton
// Added dirSep().
//
// Revision 4.1  1997/09/17 15:12:26  houghton
// Changed to Version 4
//
// Revision 3.8  1997/09/17 11:08:22  houghton
// Changed: renamed library to StlUtils.
//
// Revision 3.7  1997/07/20 18:49:53  houghton
// Changed getPath to return an empty string if there is no directory
//     part (used to return ".").
//
// Revision 3.6  1997/07/18 19:13:26  houghton
// Port(Sun5): changed all locale variables named beg and end to
//     eliminate compiler warnings.
//
// Revision 3.5  1997/03/12 12:01:41  houghton
// Added FilePath( dir, fn, ext, ddelim, edelim ) constructor.
// Cleanup comments.
//
// Revision 3.4  1997/03/03 14:35:57  houghton
// Changed base class from string back to Str (Massive improvement of
//     functionallity )
//
// Revision 3.3  1996/11/22 12:23:33  houghton
// Added 'set' methods that take 'string' (vs const char *).
//
// Revision 3.2  1996/11/20 12:06:44  houghton
// Changed: Major rework to change base class from Str to string.
//
// Revision 3.1  1996/11/14 01:23:43  houghton
// Changed to Release 3
//
// Revision 2.3  1996/04/27 12:59:46  houghton
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.2  1995/12/04 11:17:22  houghton
// Bug Fix - Can now compile with out '-DSTLUTILS_DEBUG'.
//
// Revision 2.1  1995/11/10  12:40:36  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:35  houghton
// Revised
//
//
#endif // ! def _FilePath_ii_ 

