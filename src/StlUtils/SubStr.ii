#ifndef _SubStr_ii_
#define _SubStr_ii_
//
// File:        SubStr.ii
// Desc:        
//
//  	inlines for SubStr
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     06/06/95 05:52
//
// Revision History:
//
// $Log$
// Revision 3.1  1996/11/14 01:24:24  houghton
// Changed to Release 3
//
// Revision 2.7  1996/07/09 11:34:53  houghton
// Bug-Fix: Change to StringToBool to StringTo.
//
// Revision 2.6  1996/05/25 12:36:25  houghton
// Added of method. returns owning Str.
//
// Revision 2.5  1996/05/03 16:13:52  houghton
// AIX Port cleanup.
//
// Revision 2.4  1996/04/27 13:09:56  houghton
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.3  1996/02/29 19:07:35  houghton
// Added some ifndefs for GNU
//
// Revision 2.2  1995/12/04 11:18:30  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
//
// Revision 2.1  1995/11/10  12:41:18  houghton
// Change to Version 2
//
// Revision 1.2  1995/11/05  14:44:54  houghton
// Ports and Version ID changes
//
//

#if !defined( CLUE_SHORT_FN )
#include <Str.hh>
#include <StringUtils.hh>
#include <algorithm>
#else
#include <Str.hh>
#include <StrUtil.hh>
#include <algorithm>
#endif

#if defined( CLUE_DEBUG )
#define inline
#endif

inline
SubStr::SubStr( Str & src, size_t start, size_t length )
  : str( src ),
    constStr( src ),
    pos( start ),
    len( min( src.size() - start, length ) )
{
}

inline
SubStr::SubStr( const Str & src, size_t start, size_t length )
  : str(dummyStr),
    constStr( src ),
    pos( start ),
    len( min( src.size() - start, length ) )
{
  ;
}

inline
size_t
SubStr::size( void ) const
{
  return( len );
}

inline
size_t
SubStr::length( void ) const
{
  return( size() );
}

inline
bool
SubStr::empty( void ) const
{
  return( size() == 0 );
}

inline
Str &
SubStr::of( void )
{
  return( str );
}

inline
const Str &
SubStr::of( void ) const
{
  return( str );
}

    
inline
bool
SubStr::to( bool & dest ) const
{
  return( size() ? StringTo( dest, strbase(), length() ) : false );
}

inline
bool
SubStr::to( int & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( short & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( long & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( float & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( double & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( unsigned int & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( unsigned short & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::to( unsigned long & dest, unsigned short base ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length() ) : false );
}

inline
bool
SubStr::toBool( void ) const
{
  bool dest = false;
  StringTo( dest, strbase(), length());
  return( dest );
}

inline
int
SubStr::toInt( unsigned short base ) const
{
  int dest = 0;
  to( dest, base );
  return( dest );
}

inline
long
SubStr::toLong( unsigned short base ) const
{
  long dest = 0;
  to( dest, base );
  return( dest );
}

inline
double
SubStr::toDouble( unsigned short base ) const
{
  double dest = 0;
  to( dest, base );
  return( dest );
}

inline
unsigned int
SubStr::toUInt( unsigned short base ) const
{
  unsigned int dest = 0;
  to( dest, base );
  return( dest );
}

inline
unsigned long
SubStr::toULong( unsigned short base ) const
{
  unsigned long dest = 0;
  to( dest, base );
  return( dest );
}

inline
char &
SubStr::operator [] ( size_t index )
{
  static char bad = 0;
  CLUE_EXCPT_OUT_OF_RANGE( index >= size(), bad );
  return( str[ pos + index ] );
}

inline
char 
SubStr::operator [] ( size_t index ) const
{
  CLUE_EXCPT_OUT_OF_RANGE( index >= size(), 0 );  
  return( constStr[ pos + index ] );
}

inline
SubStr &
SubStr::operator =  ( const SubStr & src )
{
  str.replace( pos, len, src );
  len = src.size();
  return( *this );
}

inline
SubStr &
SubStr::operator =  ( const Str & src )
{
  str.replace( pos, len, src );
  len = src.size();
  return( *this );
}

inline
SubStr &
SubStr::operator =  ( const char * src )
{
  str.replace( pos, len, src );
  len = strlen( src );
  return( *this );
}

inline
SubStr &
SubStr::operator =  ( char src )
{
  str.replace( pos, len, src );
  len = 1;
  return( *this );
}


inline
SubStr &
SubStr::operator += ( const SubStr & src )
{
  str.replace( pos + len, 0, src );
  len += src.size();
  return( *this );
}

inline
SubStr &
SubStr::operator += ( const Str & src )
{
  str.replace( pos + len, 0, src );
  len += src.size();
  return( *this );
}

inline
SubStr &
SubStr::operator += ( const char * src )
{
  str.replace( pos + len, 0, src );
  len += strlen( src );
  return( *this );
}

inline
SubStr &
SubStr::operator += ( char src )
{
  str.replace( pos + len, 0, src );
  len += 1;
  return( *this );
}

inline
bool
SubStr::operator == ( const SubStr & two ) const
{
  return( compare( two ) == 0 );
}

inline
bool
SubStr::operator == ( const Str & two ) const
{
  return( compare( two ) == 0 );
}

inline
bool
SubStr::operator == ( const char * two ) const
{
  return( compare( two ) == 0 );
}


inline
bool
SubStr::operator <  ( const SubStr & two ) const
{
  return( compare( two ) < 0 );
}

inline
bool
SubStr::operator <  ( const Str & two ) const
{
  return( compare( two ) < 0 );
}

inline
bool
SubStr::operator <  ( const char * two ) const
{
  return( compare( two ) < 0 );
}

inline
bool
SubStr::operator != ( const SubStr & two ) const
{
  return( ! ( *this == two ) );
}

inline
bool
SubStr::operator != ( const Str & two ) const
{
  return( ! ( *this == two ) );
}

inline
bool
SubStr::operator != ( const char * two ) const
{
  return( ! ( *this == two ) );
}

inline
bool
SubStr::operator >  ( const SubStr & two ) const
{
  return( compare( two ) > 0 );
}

inline
bool
SubStr::operator >  ( const Str & two ) const
{
  return( compare( two ) > 0 );
}

inline
bool
SubStr::operator >  ( const char * two ) const
{
  return( compare( two ) > 0 );
}

inline
bool
SubStr::operator <=  ( const SubStr & two ) const
{
  return( compare( two ) <= 0 );
}

inline
bool
SubStr::operator <=  ( const Str & two ) const
{
  return( compare( two ) <= 0 );
}

inline
bool
SubStr::operator <=  ( const char * two ) const
{
  return( compare( two ) <= 0 );
}

inline
bool
SubStr::operator >=  ( const SubStr & two ) const
{
  return( compare( two ) >= 0 );
}

inline
bool
SubStr::operator >=  ( const Str & two ) const
{
  return( compare( two ) >= 0 );
}

inline
bool
SubStr::operator >=  ( const char * two ) const
{
  return( compare( two ) >= 0 );
}


inline
bool
SubStr::good( void ) const
{
  return( constStr.good() && str.good() );
}

inline
ostream &
SubStr::toStream( ostream & dest ) const
{
  dest.write( strbase(), size() );
  return( dest );
}
    
inline
ostream &
operator << ( ostream & dest, const SubStr & src )
{
  return( src.toStream( dest ) );
}

inline
istream &
operator >> ( istream & src, SubStr & dest )
{
  Str tmp;
  src >> tmp;
  if( src.good() )
    dest = tmp;
  return( src );
}

inline
const char *
SubStr::strbase( void ) const
{
  return( constStr.strbase() + pos );
}

#if !defined( inline )
#define SUBSTR_COMP_LEN	= NPOS
#else
#define SUBSTR_COMP_LEN
#endif


inline
int
compare( const SubStr & one, const char * two, size_t len SUBSTR_COMP_LEN)
{
  return( one.compare( two, 0, len ) );
}

inline
int
fcompare( const SubStr & one, const char * two, size_t len SUBSTR_COMP_LEN)
{
  return( one.fcompare( two, 0, len ) );
}

inline
Str
operator + ( const SubStr & lhs, const Str & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const SubStr & lhs, const SubStr & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const SubStr & lhs, const char * rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const char * lhs, const SubStr & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
bool
operator == ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) == 0 );
}

inline
bool
operator != ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) != 0 );
}


inline
bool
operator <  ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) < 0 );
}

inline
bool
operator >  ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) >  0 );
}

inline
bool
operator <= ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) <= 0 );
}

inline
bool
operator >= ( const char * lhs, const SubStr & rhs )
{
  return( compare( lhs, rhs ) >= 0 );
}


inline
bool
StringToBool( const SubStr & str )
{
  return( str.toBool() );
}

#if defined( inline )
#define SUBSTR_DEF_BASE
#else
#define SUBSTR_DEF_BASE = 0
#endif

inline
int
StringToInt( const SubStr & str, unsigned short base SUBSTR_DEF_BASE )
{
  return( str.toInt( base ) );
}

inline
long
StringToLong( const SubStr & str, unsigned short base SUBSTR_DEF_BASE )
{
  return( str.toLong( base ) );
}

inline
double
StringToDouble( const SubStr & str, unsigned short base SUBSTR_DEF_BASE )
{
  return( str.toDouble( base ) );
}

inline
unsigned int
StringToUInt( const SubStr & str, unsigned short base SUBSTR_DEF_BASE )
{
  return( str.toUInt( base ) );
}

inline
unsigned long
StringToULong( const SubStr & str, unsigned short base SUBSTR_DEF_BASE )
{
  return( str.toULong( base ) );
}


#ifdef STD_STRING
inline
bool
SubStr::operator <  ( const string & two ) const
{
  return( compare( two ) < 0 );
}
#endif

#ifdef STD_STRING
inline
bool
SubStr::operator == ( const string & two ) const
{
  return( compare( two ) == 0 );
}
#endif

#ifdef STD_STRING
inline
SubStr &
SubStr::operator += ( const string & src )
{
  str.replace( pos + len, 0, src );
  len += src.size();
  return( *this );
}
#endif

#ifdef STD_STRING
inline
SubStr &
SubStr::operator =  ( const string & src )
{
  str.replace( pos, len, src );
  len = src.size();
  return( *this );
}
#endif

#if defined( inline )
#undef inline
#endif

#endif // ! def _SubStr_ii_ 
