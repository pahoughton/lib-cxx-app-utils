#ifndef _Clue_ii_
#define _Clue_ii_
//
// File:        Clue.ii
// Desc:        
//
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     05/02/95 06:32
//
// Revision History:
//
// $Log$
// Revision 2.3  1996/03/13 11:24:46  houghton
// Bug Fix: fixed include file #ifdefs
// Add: Net2Host & Host2Net translators
//
// Revision 2.2  1996/02/29 19:04:56  houghton
// Added ifdef for abs( long )
//
// Revision 2.1  1995/11/10 12:40:21  houghton
// Change to Version 2
//
// Revision 1.1  1995/11/05  13:23:18  houghton
// Initaial implementation
//
//

#if defined( inline )
#error 'inline defined'
#endif

#include <algorithm>


// tArraySize
#define ArraySize( _a_ ) ( sizeof( _a_ ) / sizeof( _a_[0] ) )


template< class NumberType >
inline
NumberType
Align( NumberType value, size_t alignSize )
{
  return( ((value % alignSize) == 0) ?
	  value :
	  ( value + ( alignSize - ( value % alignSize ) ) ) );
}

template< class NumberType >
inline
NumberType
Align( NumberType value )
{
  return( Align( value, sizeof( value ) ) );
}

  
// tDwordAlign
inline
unsigned long
DwordAlign( unsigned long value )
{
  return( Align( value, (size_t)4 ) );
}

// tDwordAlign
inline
void *
DwordAlign( void * addr )
{
  if( sizeof( unsigned long ) != sizeof( void * ) ) return( 0 );
  
  unsigned long value = (unsigned long)addr;
  return( (void *)( DwordAlign( value ) ) );
}


// tMemOverlap
inline
bool
MemOverlap( const void * one, size_t lenOne, const void * two, size_t lenTwo )
{
  const char * o = (const char *)one;
  const char * t = (const char *)two;

  return( ( ( lenOne && lenTwo ) ?
	    ( ( o <= t ) ?
	      ( ((o + lenOne)-1) >= t ) :
	      ( ((t + lenTwo)-1) >= o ) ) :
	    0 ) );
}

inline
short
Net2Host( short num )
{
  return( Net2HostShort( num ) );
}

inline
short
Host2Net( short num )
{
  return( Host2NetShort( num ) );
}

inline
unsigned short
Net2Host( unsigned short num )
{
  return( Net2HostUShort( num ) );
}

inline
unsigned short
Host2Net( unsigned short num )
{
  return( Host2NetUShort( num ) );
}

inline
int
Net2Host( int num )
{
  return( Net2HostInt( num ) );
}

inline
int
Host2Net( int num )
{
  return( Host2NetInt( num ) );
}

inline
unsigned int
Net2Host( unsigned int num )
{
  return( Net2HostUInt( num ) );
}

inline
unsigned int
Host2Net( unsigned int num )
{
  return( Host2NetUInt( num ) );
}

inline
long
Net2Host( long num )
{
  return( Net2HostLong( num ) );
}

inline
long
Host2Net( long num )
{
  return( Host2NetLong( num ) );
}

inline
unsigned long
Net2Host( unsigned long num )
{
  return( Net2HostULong( num ) );
}

inline
unsigned long
Host2Net( unsigned long num )
{
  return( Host2NetULong( num ) );
}


#if !defined( CLUE_HAVE_LONG_ABS )
inline
long
abs( long value )
{
  return( value < 0 ? (value * -1) : value );
}
#endif


// tIsBaseDigit
inline
bool
IsBaseDigit( int d, unsigned short base )
{
  return( ( d >= 0 && d < base ) );
}


inline
unsigned long
UnionOf( long startOne, long endOne, long startTwo, long endTwo )
{
  if( startTwo <= endOne &&
      endTwo >= startOne )
    {
      return( ( (endTwo - startTwo) + (endOne - startOne) -
		( abs( startOne - startTwo ) +
		  abs( endTwo - endOne ) ) ) / 2 );
    }
  return( 0 );
}

inline
unsigned long
UnionOfDur( long startOne, long durOne, long startTwo, long durTwo )
{
  if( startTwo <= startOne + durOne &&
      startTwo + durTwo >= startOne )
    {
      return( ( (durTwo + durOne) -
		( abs( startOne - startTwo ) +
		  abs( (startTwo + durTwo ) - (startOne + durOne) ) ) ) / 2 );
    }

  return( 0 );
}

inline
unsigned long
UnionOfDur(
  unsigned long startOne,
  unsigned long durOne,
  unsigned long startTwo,
  unsigned long durTwo,
  unsigned long frequency
  )
{
  unsigned long	    unionSum = 0;

  for( unsigned long startOfOne = startOne;
       startOfOne < (startTwo + durTwo );
       startOfOne += frequency )
    {
      unionSum += UnionOfDur( startOfOne, durOne, startTwo, durTwo );
    }

  return( unionSum );
}      

template< class NumberType >
inline
NumberType
Round( NumberType value, int factor )
{
  NumberType remain = value % factor;

  if( remain < ((factor + 1) / 2) )
    {
      return( value - remain );
    }
  else
    {
      return( value + ( factor - remain ) );
    }
}

template< class NumberType >
inline
NumberType
RoundUp( NumberType value, int factor  )
{
  NumberType remain = value % factor;

  if( remain == 0 )
    {
      remain = factor;
    }

  return( (value - remain) + factor );
}

template< class NumberType >
inline
NumberType
RoundDown( NumberType value, int factor  )
{

  NumberType remain = value % factor;

  return( value - remain );
}

#endif // ! def _Clue_ii_ 


