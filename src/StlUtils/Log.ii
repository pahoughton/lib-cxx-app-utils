#ifndef _Log_ii_
#define _Log_ii_
//
// File:        Log.ii
// Desc:        
//
//  	inlines for Log
//
// Author:      Paul Houghton - (paul_houghton@wiltel.com)
// Created:     07/21/95 12:52
//
// Revision History:
//
// $Log$
// Revision 2.5  1996/10/22 22:05:51  houghton
// Change: Added locStamp to turn on/off output of src file & line.
//
// Revision 2.4  1996/04/27 13:03:13  houghton
// Added thread locking support.
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.3  1995/12/04 11:17:23  houghton
// Bug Fix - Can now compile with out '-DCLUE_DEBUG'.
//
// Revision 2.2  1995/11/12  18:01:54  houghton
// Added srcFile, srcLine args to level().
// Change LogLevel::XXXX to LogLevel::Xxxxx.
//
// Revision 2.1  1995/11/10  12:40:44  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:38  houghton
// Revised
//
//

#if defined( CLUE_DEBUG )
#define inline
#endif

inline
Log::Log(
    ostream & 		outstr,
    LogLevel::Level 	out,
    bool		stampLevel,
    bool		stampTime,
    bool		stampLoc
    )
  : ostream( new LogBuf( out, outstr.rdbuf() ) ),
    timeStamp( stampTime ),
    levelStamp( stampLevel ),
    locStamp( stampLoc )
{
  tie( &outstr );
}

inline
Log::Log(
    ostream & 		outstr,
    const char *	out,
    bool		stampLevel,
    bool		stampTime,
    bool		stampLoc
    )
  : ostream( new LogBuf( out, outstr.rdbuf() ) ),
    timeStamp( stampTime ),
    levelStamp( stampLevel ),
    locStamp( stampLoc )    
{
  tie( &outstr );
}

inline
Log::Log(
    const char * 	fileName,
    LogLevel::Level 	out,
    bool		stampLevel,
    bool		stampTime,
    bool		stampLoc,
    ios::open_mode	mode,
    int			prot,
    size_t		maxSize,
    size_t		trimSize
    )
  : ostream( new LogBuf(fileName, out, mode, prot, maxSize, trimSize ) ),
    timeStamp( stampTime ),
    levelStamp( stampLevel ),
    locStamp( stampLoc )    
{
}

inline
Log::Log(
    const char * 	fileName,
    const char *	out,
    bool		stampLevel,
    bool		stampTime,
    bool		stampLoc,
    ios::open_mode	mode,
    int			prot,
    size_t		maxSize,
    size_t		trimSize
    )
  : ostream( new LogBuf(fileName, out, mode, prot, maxSize, trimSize ) ),
    timeStamp( stampTime ),
    levelStamp( stampLevel ),
    locStamp( stampLoc )    
{
}

inline
Log::~Log( void )
{
  delete rdbuf();
}

inline
void
Log::tee( ostream & teeStream )
{
  rdbuf()->tee( teeStream.rdbuf() );
}

inline
size_t
Log::trim( size_t maxSize )
{
  return( rdbuf()->trim( maxSize ) );
}

inline
size_t
Log::setMaxSize( size_t max )
{
  return( rdbuf()->setMaxSize( max ) );
}

inline
size_t
Log::setTrimSize( size_t size )
{
  return( rdbuf()->setTrimSize( size ) );
}


inline
Log &
Log::operator () ( void )
{
  return( level( LogLevel::Error ) );
}

inline
Log &
Log::operator () ( LogLevel::Level lvl )
{
  return( level( lvl ) );
}

inline
Log &
Log::operator () ( LogLevel::Level lvl, const char * srcFile, long srcLine )
{
  return( level( lvl, srcFile, srcLine ) );
}

inline
Log &
Log::operator () ( const char * lvl )
{
  return( level( lvl ) );
}

inline
Log &
Log::operator () ( const char * lvl, const char * srcFile, long srcLine )
{
  return( level( lvl, srcFile, srcLine ) );
}

inline
void
Log::on( LogLevel::Level out )
{
  rdbuf()->sync();
  rdbuf()->level().setOutput( (LogLevel::Level) (getOutput() | out) );
}

inline
void
Log::off( LogLevel::Level out )
{
  rdbuf()->sync();
  rdbuf()->level().setOutput( (LogLevel::Level) (getOutput() & ~out) );
}

inline
LogLevel::Level
Log::getCurrent( void ) const
{
  return( rdbuf()->level().getCurrent() );
}

inline
LogLevel::Level
Log::getOutput( void  ) const
{
  return( rdbuf()->level().getOutput() );
}

inline
bool
Log::willOutput( LogLevel::Level outLevel ) const
{
  return( rdbuf()->willOutput( outLevel ) );
}

inline
void
Log::setFileName( const char * outFn, int mode )
{
  open( outFn, mode );
}

inline
void
Log::open( const char * outFn, int mode )
{
  rdbuf()->close();
  clear();
  if( rdbuf()->open( outFn, (ios::open_mode)mode ) == 0 )
    {
      setstate( failbit );
    }
}

inline
void
Log::close( void )
{
  if( rdbuf()->sync() == EOF )
    {
      setstate( eofbit | failbit );
    }
  
  rdbuf()->close();
}

inline
LogLevel::Level
Log::setOutputLevel( const char * level )
{
  rdbuf()->sync();
  return( rdbuf()->level().setOutput( level ) );
}

inline
LogLevel::Level
Log::setOutputLevel( LogLevel::Level level )
{
  rdbuf()->sync();
  return( rdbuf()->level().setOutput( level ) );
}


inline
bool
Log::setLevelStamp( bool stamp )
{
  bool old = levelStamp;
  levelStamp = stamp;
  return( old );
}

inline
bool
Log::setTimeStamp( bool stamp )
{
  bool old = timeStamp;
  timeStamp = stamp;
  return( old );
}

inline
bool
Log::setLocStamp( bool stamp )
{
  bool old = locStamp;
  locStamp = stamp;
  return( old );
}

inline
LogBuf *
Log::rdbuf( void )
{
  return( (LogBuf *)(ios::rdbuf()) );
}

inline
const LogBuf *
Log::rdbuf( void ) const
{
#ifdef AIX
  // aix does not have a const rdbuf
  return( (const LogBuf *)(bp) );
#else
  return( (LogBuf *)(ios::rdbuf()) );
#endif
  
}


inline
bool
Log::lock( void )
{
  return( mutex.lock() );
}

inline
bool
Log::unlock( void )
{
  return( mutex.unlock() );
}

#if defined( inline )
#undef inline
#endif


#endif // ! def _Log_ii_ 

